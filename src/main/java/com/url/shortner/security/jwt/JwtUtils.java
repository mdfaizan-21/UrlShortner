package com.url.shortner.security.jwt;

import com.url.shortner.services.UserDetailsImpl;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import jakarta.servlet.http.HttpServletRequest;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.security.Key;
import java.util.Date;
import java.util.stream.Collectors;

@Component
/* this class contains all the utility helper methods that our application
 is going to be required for the purpose of authentication and authorization
 */
public class JwtUtils {

    @Value("${jwt.expiration}")
    private int jwtExpiration;
    @Value("${jwt.secret}")
    private String  jwtSecret;

    // Extracts the JWT token from the Authorization header of the request
    // Authorization header format: "Bearer <TOKEN>"
    public String getJwtFromHeader(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        // Check if the header starts with "Bearer " and is not null
        if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7); // Remove "Bearer " prefix to get the actual token
        }
        return null; // Return null if header is missing or invalid
    }

    public String generateToken(UserDetailsImpl userDetails) {
        // Retrieves the unique username from the custom UserDetails implementation
        String username = userDetails.getUsername();

        // Converts the Collection of GrantedAuthority objects into a single comma-separated String
        // Example: ["ROLE_USER", "ROLE_ADMIN"] becomes "ROLE_USER,ROLE_ADMIN"
        String roles = userDetails.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority) // Extracts the string representation of each authority
                .collect(Collectors.joining(","));   // Joins them with a comma delimiter

        // Starts the Fluent API builder provided by the JJWT library to construct the token
        return Jwts.builder()
                // Sets the "sub" (subject) claim, which usually represents the user the token belongs to
                .subject(username)
                // Adds a custom claim named "roles" containing the comma-separated string created above
                .claim("roles", roles)
                // Sets the "iat" (issued at) claim with the current system date and time
                .issuedAt(new Date())
                // Sets the "exp" (expiration) claim by adding the configured milliseconds to the current time
                .expiration(new Date(new Date().getTime() + jwtExpiration))
                // Signs the JWT using the HMAC-SHA algorithm and the secret key generated by getkey()
                .signWith(getkey())
                // Finalizes the construction and serializes the JWT into its compact, URL-safe string format
                .compact();
    }

    public String getUserNameFromJwtToken(String token) {
        // Initializes the JWT parser builder
        return Jwts.parser()
                // Provides the secret key used to verify that the token's signature is authentic
                .verifyWith((SecretKey) getkey())
                // Builds the parser instance and uses it to parse the signed JWT string
                // This will throw an exception if the signature is invalid or the token is expired
                .build().parseSignedClaims(token)
                // Accesses the 'Payload' (the middle part of the JWT)
                .getPayload()
                // Retrieves the 'Subject' field from the payload (the username we set during generation)
                .getSubject();
    }

    public boolean validateToken(String token) {
        try {
            // Initializes the JWT parser builder
            Jwts.parser()
                    // Supplies the SecretKey required to check the cryptographic signature of the token
                    .verifyWith((SecretKey) getkey())
                    // Builds the parser instance based on the provided configuration
                    .build()
                    // Attempts to parse the token; this step performs the actual validation
                    // (checks signature, expiration date, and 'not before' constraints)
                    .parseSignedClaims(token);

            // If the line above executes without throwing an exception, the token is valid
            return true;

        } catch (Exception e) {
            // If any error occurs (ExpiredJwtException, MalformedJwtException, etc.),
            // the code enters this block.
            // Currently, it wraps the error in a RuntimeException and terminates the flow.
            throw new RuntimeException(e);
        }
    }

    private Key getkey() {
        // Decodes the Base64-encoded secret string from your properties file into a raw byte array
        byte[] keyBytes = Decoders.BASE64.decode(jwtSecret);

        // Creates a HMAC (Hash-based Message Authentication Code) cryptographic signing key
        // suitable for use with the HMAC-SHA algorithms based on the provided byte array
        return Keys.hmacShaKeyFor(keyBytes);
    }
}
